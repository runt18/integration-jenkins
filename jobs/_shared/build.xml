<?xml version="1.0" encoding="UTF-8" ?>
<!-- vim: set ts=2 sw=2 noet: -->

<!--
	ant build file for MediaWiki Core continuous integration

	git macros from http://tlrobinson.net/blog/2008/11/ant-tasks-for-git/
-->
<project name="MediaWiki" default="build">

	<!-- Import environnement: -->
	<property environment="env" />

	<property name="phpunitexcludes" value="Broken,ParserFuzz,Stub" />

	<!-- Import generic settings and validate existance -->

	<!-- private.properties for password. it is in .gitignore -->
	<property file="private.properties" />

	<!-- job.properties file is at the job level. Useful to override generic
		 properties -->
	<property file="job.properties" />

	<!-- then load the default.properties, setting any values which have not been
	     set previously -->
	<property file="default.properties" />

	<!--
		In case they have not been defined above, set sourcedir and buildir
		to this job workspace which is most of the case a sane default.
	-->
	<property name="sourcedir" value="${env.WORKSPACE}" />
	<property name="builddir" value="${env.WORKSPACE}" />

	<!-- ant -Dmw.database=sqlite -->
	<target name="select-database" unless="mw.database">
		<input
			message      = "Select a database backend or set mw.database in local.properties"
			validargs    = "sqlite, postgre, mysql"
			defaultvalue = "sqlite"
			addproperty  = "mw.database"
		/>
	</target>
	<target name="select-branch" unless="mw.branch">
		<input
			message      = "Specify a branch or set mw.branch in local.properties"
			defaultvalue = "trunk"
			addproperty  = "mw.branch"
		/>
	</target>


	<target name="build" depends="install" description="Main entry point" />

	<!-- Entry point to build the Wikidata project -->
	<target name="build-wikidata" depends="-import-gerrit-env">
		<!-- We need a copy of mediawiki/core.git@Wikidata -->
		<import-project
			name="mediawiki/core"
			/>

		<!-- Import some extension dependencies: -->
		<import-extension name="cldr" />
		<import-extension name="UniversalLanguageSelector" />
		<import-extension name="Wikibase" />
		<import-extension name="Diff" />
		<import-extension name="DataValues" />

		<!-- Apply Gerrit change to the extension -->
		<gerrit-apply-change
			dir="${sourcedir}/extensions/Wikibase"
			/>

		<antcall target="php-lint" />
		<!-- fixme: should just test @group Wikibase -->
	</target>

	<!-- For jobs reacting to changes made to an Extension, this will setup
			 the extension according to Gerrit project name.
			 TODO: handle extensions dependencies
			 -->
	<target name="setup-extension" depends="-import-gerrit-env">
		<!-- Split gerrit project name to only retains the last part
				 aka: 'mediawiki/extensions/RSS' => 'RSS'
		-->

		<!-- Use latest mediawiki/core@master -->
		<git-remote-update dir="${git.shared.dir}/mediawiki/core" />
		<git-snapshot
			remote="${git.shared.dir}/mediawiki/core"
			treeish="origin/master"
			dest="${sourcedir}"
		/>

		<!-- Import the extension referenced by Gerrit change -->
		<loadresource property="mediawiki.extension.name">
			<string value="${gerrit.project}" />
			<filterchain>
				<tokenfilter>
					<containsregex pattern=".*/(.*)" replace="\1" />
				</tokenfilter>
			</filterchain>
		</loadresource>

		<import-extension name="${mediawiki.extension.name}" />

		<gerrit-apply-change
			dir="${sourcedir}/extensions/${mediawiki.extension.name}"
			/>

		<!-- Import MediaWiki extensions
				 Defined as a comma list in mw.dependencies.extensions, will
				simply call the <import-extension name="foo" /> on each element
				 -->
        <script language="javascript"> <![CDATA[
list = project.getProperty( "mw.dependencies.extensions" );
if( list ) { // FIXME find out how to do an early 'return'
    exts = list.split(',');
    for each (var extension in exts) {
        // Mimic <import-extension name="$extension" />
        task = project.createTask( 'import-extension' );

				// Make sure target belong to something or we get a NPE
				// http://stackoverflow.com/questions/12280295
				task.setOwningTarget( self.getOwningTarget() );

        task.setDynamicAttribute( 'name', extension );
				task.execute();
    }
}
        ]]></script>

	</target>

	<target name="install" depends="clean,create-dirs,installdb">
	</target>

	<target name="create-dirs">
		<echo level="info">Creating basic build directory tree</echo>
		<mkdir dir="${builddir}" />
		<mkdir dir="${builddir}/api" />
		<mkdir dir="${builddir}/data" />
		<mkdir dir="${builddir}/charts" />
		<mkdir dir="${builddir}/coverage" />
		<mkdir dir="${builddir}/dist" />
		<mkdir dir="${builddir}/logs" />
		<mkdir dir="${builddir}/php-code-browser" />
	</target>

	<!-- Database installation targets -->
	<target name="installdb" depends="select-database">
		<echo>Running MediaWiki installer for database ${mw.database}</echo>
		<antcall target="installdb-${mw.database}" />
		<!-- Append a call to extrasettings -->
		<echo>Injecting include_once() of ExtraSettings.php files</echo>
		<echo append="true" file="${builddir}/LocalSettings.php">
<![CDATA[
# START: PHP code inserted automatically by build job

# Inject any extensions
require_once( dirname(dirname("${sourcedir}")).'/_shared/InjectExtensions.php' );

# Include ExtraSettings.php provided in source directory
if( file_exists( "${sourcedir}".'/ExtraSettings.php' ) ) {
	require_once( "${sourcedir}".'/ExtraSettings.php' );
}
# ... or its parent path
if( file_exists( dirname("${sourcedir}").'/ExtraSettings.php' ) ) {
	require_once( dirname("${sourcedir}").'/ExtraSettings.php' );
}
# And finally the globally shared setting
if( file_exists( dirname(dirname("${sourcedir}")).'_shared/ExtraSettings.php' ) ) {
	require_once( dirname(dirname("${sourcedir}")).'_shared/ExtraSettings.php' );
}
# END: PHP code inserted automatically by build job
]]>
</echo>
		<!-- Make sure we apply the extensions updates as well -->
		<echo level="info">Running MediaWiki update</echo>
		<exec executable="php" dir="${builddir}/" failonerror="true">
			<arg line="${sourcedir}/maintenance/update.php --quick --conf ${builddir}/LocalSettings.php" />
		</exec>
	</target>

	<target name="installdb-mysql" depends="create-dirs,cleandb-mysql,nolocalsettings">
		<fail>Install not implemented for MySQL</fail>
	</target>
	<target name="installdb-postgre" depends="create-dirs,cleandb-postgre,nolocalsettings">
		<exec executable="php" dir="${builddir}/" failonerror="true">
			<arg line="${sourcedir}/maintenance/install.php
				--confpath ${builddir}
				--dbtype=postgres
				--dbname=${pgdb}
				--dbuser=wikiuser
				--dbpass='${pgpass}'
				--installdbuser=jenkins
				--installdbpass=jenkins
				--showexceptions=true
				--pass testpass
				postgrestest
				WikiAdmin
			"/>
		</exec>
	</target>
	<target name="installdb-sqlite" depends="create-dirs,cleandb-sqlite,nolocalsettings">
		<exec executable="php" dir="${builddir}/" failonerror="true">
			<arg line="${sourcedir}/maintenance/install.php
				--confpath ${builddir}
				--dbtype=sqlite
				--dbpath=${builddir}/data
				--showexceptions=true
				--pass testpass
				sqlitetest
				WikiAdmin
			"/>
		</exec>
	</target>

	<target name="fake-localsettings" depends="create-dirs">
		<touch file="${builddir}/LocalSettings.php" />
	</target>

	<target name="nolocalsettings" description="Delete LocalSettings.php">
		<echo level="info">Deleting LocalSettings.php</echo>
		<delete file="${sourcedir}/LocalSettings.php" />
		<delete file="${builddir}/LocalSettings.php" />
	</target>

	<target name="clean" depends="cleandb, nolocalsettings" />

	<!-- Delete anything under "extensions" directory -->
	<target name="cleanextensions">
		<delete includeemptydirs="true" >
			<fileset dir="${builddir}/extensions" includes="**/*" />
		</delete>
	</target>

	<!-- Database cleaning targets -->
	<target name="cleandb"
		depends="select-database"
		description="Clean database (set mw.database)">
		<echo>Cleaning database!</echo>
		<antcall target="cleandb-${mw.database}" />
	</target>
	<target name="cleandb-mysql">
		<echo>Cleaning MySQL!</echo>
		<fail>Database cleaning not implemented for MySQL</fail>
	</target>
	<target name="cleandb-postgre">
		<echo>Cleaning PostgreSQL!</echo>
		<exec executable="dropdb">
			<arg line="-e ${pgdb}" />
		</exec>
	</target>
	<target name="cleandb-sqlite">
		<echo>Cleaning SQLite!</echo>
		<delete file="${builddir}/data/my_wiki.sqlite" />
	</target>

	<target name="-import-gerrit-env"
		description="Import env variables set by Jenkins Gerrit trigger">
		<fail>
			<condition>
				<not><and>
					<!-- only checking criticals variables for now -->
					<isset property="env.GERRIT_BRANCH" />
					<isset property="env.GERRIT_CHANGE_NUMBER" />
					<isset property="env.GERRIT_PATCHSET_NUMBER" />
				</and></not>
			</condition>
Requires some Gerrit environnement to be set, usually through the Gerrit trigger plugin.
Something must be wrong, when running from CLI, you should at least
set the following environnement variables:
- GERRIT_BRANCH
- GERRIT_CHANGE_NUMBER
- GERRIT_PATCHSET_NUMBER
		</fail>
		<echo>Importing Gerrit environnement as ant variables...</echo>
		<property name="gerrit.branch"                  value="${env.GERRIT_BRANCH}" />
		<property name="gerrit.change.number"           value="${env.GERRIT_CHANGE_NUMBER}" />
		<property name="gerrit.change.id"               value="${env.GERRIT_CHANGE_ID}" />
		<property name="gerrit.patchset.number"         value="${env.GERRIT_PATCHSET_NUMBER}" />
		<property name="gerrit.patchset.revision"       value="${env.GERRIT_PATCHSET_REVISION}" />
		<property name="gerrit.refspec"                 value="${env.GERRIT_REFSPEC}" />
		<property name="gerrit.newrev"                  value="${env.GERRIT_NEWREV}" />
		<property name="gerrit.project"                 value="${env.GERRIT_PROJECT}" />
		<property name="gerrit.change.subject"          value="${env.GERRIT_CHANGE_SUBJECT}" />
		<property name="gerrit.change.url"              value="${env.GERRIT_CHANGE_URL}" />
		<property name="gerrit.change.owner"            value="${env.GERRIT_CHANGE_OWNER}" />
		<property name="gerrit.change.owner.name"       value="${env.GERRIT_CHANGE_OWNER_NAME}" />
		<property name="gerrit.change.owner.email"      value="${env.GERRIT_CHANGE_OWNER_EMAIL}" />
		<property name="gerrit.patchset.uploader"       value="${env.GERRIT_PATCHSET_UPLOADER}" />
		<property name="gerrit.patchset.uploader.name"  value="${env.GERRIT_PATCHSET_UPLOADER_NAME}" />
		<property name="gerrit.patchset.uploader.email" value="${env.GERRIT_PATCHSET_UPLOADER_EMAIL}" />
		<!-- Dump properties defined just above: -->
		<echoproperties prefix="gerrit." />
	</target>

	<!-- Takes a copy of a MediaWiki install -->
	<target name="testswarm-snapshot" depends="-import-gerrit-env,install">
		<fail>
			<condition>
			<not><and>
				<isset property="gerrit.change.number" />
				<isset property="gerrit.patchset.number" />
				<isset property="gerrit.branch" />
			</and></not>
			</condition>
			This ant target requires both GERRIT_CHANGE_NUMBER and GERRIT_PATCHSET_NUMBER environnement variables to be set or at least their ant equivalents `gerrit.change.number` and `gerrit.patchset.number`.
		</fail>

		<!-- some testswarm specific properties depending on gerrit context -->
		<property
			name="changePath"
			value="${gerrit.change.number}/${gerrit.patchset.number}" />
		<property
			name="testswarm.publicdir"
			value="${testswarm.basedir}/clone/${changePath}" />
		<property
			name="testswarm.sqlite.dir"
			value="${testswarm.basedir}/db/${changePath}" />
		<property
			name="testswarm.sqlite.file"
			value="${testswarm.sqlite.dir}/my_wiki.sqlite" />
		<!-- Dump properties defined just above: -->
		<echoproperties prefix="testswarm." />

		<!-- create various directories -->
		<mkdir dir="${testswarm.sqlite.dir}" />
		<mkdir dir="${testswarm.publicdir}" />
<!--
		<mkdir dir="${testswarm.basedir}/conf" />
		<mkdir dir="${testswarm.basedir}/log" />
-->
		<!-- apply "sane" permissions to files in the base directory -->
		<chmod perm="2775">
			<dirset dir="${testswarm.basedir}">
				<include name="*" />
			</dirset>
		</chmod>
		<!-- the `db` path need to be in the www-data group. That is done by puppet -->

		<!-- Snapshot the sqlite database -->
		<echo>Copying sqlite database</echo>
		<copy
			file="${builddir}/data/my_wiki.sqlite"
			tofile="${testswarm.sqlite.file}"
			/>
		<!-- Both sqlite file and directory need to be writable by apache -->
		<!-- FIXME!! www-data should be enforced by g+s already :-(  -->
		<chmod perm="go+w" dir="${testswarm.sqlite.dir}" />
		<chmod perm="go+w" file="${testswarm.sqlite.file}" />

		<!-- Snapshot MediaWiki files -->
		<!-- FIXME: this should most probably uses `git clone` -->
		<echo>Publishing MediaWiki files</echo>
		<copy todir="${testswarm.publicdir}">
			<fileset dir="${sourcedir}">
				<exclude name="**/.git/" />
			</fileset>
		</copy>

		<echo>Copying LocalSettings.php</echo>
		<copy
			file="${builddir}/LocalSettings.php"
			todir="${testswarm.publicdir}"
		/>
		<echo>Copying ExtraSettings.php</echo>
		<copy
			file="${basedir}/ExtraSettings.php"
			todir="${testswarm.publicdir}"
		/>

		<echo>Tweaking configuration</echo>
		<!-- TODO actually copy the ExtraSettings file -->

		<!-- Property containing the URL path -->
		<property name="testswarm.URL.path"
			value="${testswarm.URL.basepath}/${changePath}" />

		<replace file="${testswarm.publicdir}/LocalSettings.php">
			<!-- Replace $wgServer value -->
			<replacefilter
				token="http://localhost"
				value="${testswarm.URL.scheme}${testswarm.URL.authority}"
			/>
		<replacefilter>
			<replacetoken><![CDATA[$wgScriptPath       = "/wiki";]]></replacetoken>
			<replacevalue expandProperties="true"><![CDATA[$wgScriptPath       = "${testswarm.URL.path}";]]></replacevalue>
		</replacefilter>
		<replacefilter>
			<replacetoken expandProperties="true">${builddir}/data</replacetoken>
			<replacevalue expandProperties="true">${testswarm.sqlite.dir}</replacevalue>
		</replacefilter>
		</replace>

		<!-- TODO: alter extrasettings.php? -->
	</target>

	<!-- Submit a job to TestSwarm -->
	<target name="testswarm-submitjob" depends="testswarm-snapshot">
		<echo>Attempting submission to TestSwarm</echo>
		<exec executable="php" dir="${testswarm.submit.path}" failonerror="true">
			<arg line="${testswarm.submit.script}" />
			<arg line="--change   ${gerrit.change.number}" />
			<arg line="--patchset ${gerrit.patchset.number}" />
			<arg line="--commit   ${gerrit.patchset.revision}" />
			<arg line="--branch   ${gerrit.branch}" />
		</exec>
	</target>

	<!-- PHPUnit related targets -->
	<target name="phpunit-databaseless" depends="fake-localsettings">
		<run-phpunit options="--exclude-group Database,${phpunitexcludes}" />
	</target>

	<target name="phpunit-databased" depends="phpunit-parser, phpunit-api, phpunit-dump" />

	<!-- Sub targets, whenever you add a new group, make sure to also have
	     it excluded from the phpunit-misc job
	     -->
	<target name="phpunit-dump" depends="installdb">
		<run-phpunit options="--group Dump --exclude-group ${phpunitexcludes}"/>
	</target>
	<target name="phpunit-parser" depends="installdb">
		<run-phpunit options="--group Parser --exclude-group ${phpunitexcludes}"/>
	</target>
	<target name="phpunit-api" depends="installdb">
		<run-phpunit options="--group API --exclude-group ${phpunitexcludes}"/>
	</target>
	<!-- Exclude any group defined above:-->
	<target name="phpunit-misc" depends="installdb">
		<run-phpunit options="--group Database --exclude-group API,Dump,Parser,${phpunitexcludes}"/>
	</target>

	<!-- Execute phpunit on each sub directory of 'extensions' -->
	<target name="phpunit-extensions" depends="installdb">
		<run-phpunit options="--exclude-group ${phpunitexcludes}"
			directory="${sourcedir}/extensions" />
	</target>

	<!-- Macro to run some phpunit tests
	     @param Options Additional parameters to pass to PHPUnit
	-->
	<macrodef name="run-phpunit">
		<attribute name="options" default="" />
		<attribute name="directory" default="" />

		<sequential>
		<echo>Builddir: ${builddir}</echo>
		<echo>Logdir..: ${builddir}/logs/</echo>
		<echo>Indir...: ${sourcedir}/tests/phpunit</echo>
		<echo>Opts....: @{options} -- @{directory}</echo>
		<exec executable="php" dir="${sourcedir}/tests/phpunit" failonerror="true">
			<arg line="phpunit.php --conf ${builddir}/LocalSettings.php @{options} --log-junit ${builddir}/logs/junit.xml -- @{directory}" />
		</exec>
		</sequential>
	</macrodef>

	<!-- git-files-changed:
		Find out uwhat file changed in git copy ${sourcedir} before HEAD

		Example:
		  ant git-files-changed -Dsourcedir=/var/www/mediawiki
	-->
	<target name="git-files-changed">
		<exec executable="git" dir="${sourcedir}" failonerror="true"
			outputproperty="gitfileschanged">
			<arg line="diff --name-only HEAD^" />
		</exec>
		<echo>Files changed according to git:</echo>
		<echo>--------------------------------------------------------------</echo>
		<echo>${gitfileschanged}</echo>
		<echo>--------------------------------------------------------------</echo>
		<!-- Create a new property with only php files: -->
		<exec executable="grep"
			inputstring="${gitfileschanged}"
			outputproperty="gitphpfileschanged">
			<arg value="-E" />
			<arg value="\.(php|php5|inc|phtml)$" />
			</exec>
		<!-- find out files ending with .sql -->
		<exec executable="grep"
			failonerror="false"
			inputstring="${gitfileschanged}"
			resultproperty="gitgrepsqlresult"
			outputproperty="gitsqlfileschanged">
			<arg value="-E" />
			<arg value="\.(sql)$" />
			</exec>

		<!-- Create a new property without newlines: -->
		<exec executable="tr"
			inputstring="${gitfileschanged}"
			outputproperty="gitfileschangedinline">
			<arg value="\n" />
			<arg value=" " />
			</exec>

		<!-- set a property whether any .sql file got changed -->
		<condition property="gitsqlhaschanged" value="true" else="false">
			<equals arg1="${gitgrepsqlresult}" arg2="0" />
		</condition>
		<echo>.sql file changed? ${gitsqlhaschanged}</echo>

	</target>

	<!-- php-lint:
		A very very basic linter using `php -l`
		To test this target locally you could override the sourcedir variable
		to point to a local checkout of a git repository.

		Example:
		  ant php-lint -Dsourcedir=/var/www/mediawiki
	-->
	<!-- FIXME: find a way to limit list of files to *.php *.inc *.phtml *.php5 -->
	<target name="php-lint" depends="git-files-changed">
		<echo>Blindly running `php -l` on modified PHP files:</echo>
		<apply
			executable="php"
			relative="true"
			dir="${sourcedir}"
			failonerror="true"
			verbose="true"
		>
			<arg value="-l" />
			<filelist dir="${sourcedir}" files="${gitphpfileschanged}" />
		</apply>
	</target>

	<!-- check code style on files changed by HEAD -->
	<target name="checkstyle" depends="create-dirs,git-files-changed">
		<echo>Running PHP CodeSniffer in ${sourcedir}</echo>
		<!--
				Must have git-files-changed target executed before.
				The target will generate gitfileschangedinline property
				which list all modified files on a single line
		-->
		<exec executable="phpcs" dir="${sourcedir}" output="${builddir}/logs/checkstyle.xml">
			<arg line="--report=checkstyle --standard=../../../tools/MediaWiki-CodeSniffer/MediaWiki --ignore='Messages*.php,*.css,*.js' ${gitfileschangedinline}"/>
		</exec>
		<echo>PHP CodeSniffer apparently finished analysis.</echo>
	</target>

	<target name="properties" description="Dump ant properties">
		<echoproperties />
	</target>

	<!-- apply the Gerrit change to a git working directory -->
	<macrodef name="gerrit-apply-change">
		<attribute name="dir" />
		<attribute name="branch"  default="${gerrit.branch}" />
		<attribute name="refspec" default="${gerrit.refspec}" />
		<sequential>
			<echo>Applying @{refspec} from @{branch} to @{dir}</echo>
			<git-checkout  dir="@{dir}"
				commit="@{branch}" />
			<git-reset         dir="@{dir}"
				mode="--hard" commit="@{branch}" />
			<git-clean-dfqx dir="@{dir}" />
			<git-fetch dir="@{dir}"
				repository="origin" refspec="@{refspec}" />
			<git-merge-fetchhead dir="@{dir}" />
		</sequential>
	</macrodef>

	<!-- Takes snapshots of FETCH_HEAD files in "fingerprints" dir
		Example usage:
		ant take-fingerprints -Dsourcedir=/working/copy
	-->
	<target name="take-fingerprints">
		<jenkins-fingerprint
			dir="${sourcedir}"
			todir="${builddir}/fingerprints"
		/>
	</target>

	<!-- Copy files matching .git/FETCH_HEAD under 'fingerprints' using
		the directory name to forge a new name. Example output:
		$ ls -1 $WORKSPACE/fingerprints
		workspace
		workspace_extensions_Wikibase
	-->
	<macrodef name="jenkins-fingerprint">
		<!-- Base directory to look for fingerprints -->
		<attribute name="dir"   default="." />
		<attribute name="todir" default="@{dir}/fingerprints" />
		<sequential>
			<echo>Fingerprinting @{dir}</echo>
			<echo>To @{dir}/fingerprints</echo>
			<!-- verbose and overwrite to make sure user see what is going on -->
			<copy todir="@{todir}"
				overwrite="yes"
				preservelastmodified="yes"
				verbose="yes"
			>
				<!-- find .git/FETCH_HEAD files -->
				<fileset dir="@{dir}" defaultexcludes="no" includes="**/.git/FETCH_HEAD" />
				<!-- strip git/FETCH_HEAD, replaces slashes by underscores -->
				<filtermapper>
					<replacestring from=".git/FETCH_HEAD" to="_git_FETCH_HEAD" />
					<replacestring from="/" to="_" />
				</filtermapper>
			</copy>
		</sequential>
	</macrodef>


	<!-- Clone a gerrit project unless it is already there -->
	<target name="clone-gerrit-project"
		description="Clone a gerrit project to `git.shared.dir`"
		unless="git.shared.exist.${name}"
	>
		<fail unless="name">
			clone-gerrit-project require a Gerrit project name passed as 'name'
		</fail>
		<echo>Cloning from : ${gerrit.baseurl}/${name}</echo>
		<echo>To shared dir: ${git.shared.dir}/${name}</echo>
		<git-clone
			repository="${gerrit.baseurl}/${name}.git"
			dest="${git.shared.dir}/${name}"
			/>
	</target>

	<!-- locally copy a project from the shared repo to a local dest -->
	<target name="copy-project">
		<echo>Clone: ${gerrit.baseurl}/${name}.git</echo>
		<echo>To: ${dest}</echo>
		<echo>Ref: ${git.shared.dir}/${name}</echo>
		<git-clone
			failonerror="false"
			options="--reference ${git.shared.dir}/${name}"
			repository="${gerrit.baseurl}/${name}.git"
			dest="${dest}"
			branch="${branch}" />
	</target>

	<!-- Import and initalize a shared git repo in working directory -->
	<macrodef name="import-project">
		<attribute name="name" />
		<attribute name="branch" default="master" />
		<attribute name="dest"   default="${sourcedir}" />
		<sequential>
			<!-- Check existence of a git clone in the shared repo: -->
			<git-cloned name="@{name}" />

			<!-- Eventually clone project from the Gerrit repository -->
			<antcall target="clone-gerrit-project">
				<param name="name"   value="@{name}"   />
			</antcall>

			<!-- make sure the shared repo is up to date -->
			<git-remote-update dir="${git.shared.dir}/@{name}" />

			<!-- Copy from shared repo to dest (usually a Jenkins workspace -->
			<antcall target="copy-project">
				<param name="name"   value="@{name}"   />
				<param name="branch" value="@{branch}" />
				<param name="dest"   value="@{dest}"   />
			</antcall>

			<!-- While we are at it, make dest clean -->
			<git-remote-update dir="@{dest}" />
			<git-reset-hard dir="@{dest}" commit="remotes/origin/@{branch}" />
			<git-checkout   dir="@{dest}" />
			<git-clean-dfqx dir="@{dest}" />
		</sequential>
	</macrodef>

	<!-- Helper to easily import a MediaWiki extension -->
	<macrodef name="import-extension">
		<attribute name="name" />
		<sequential>
			<import-project
				name="mediawiki/extensions/@{name}"
				dest="${sourcedir}/extensions/@{name}"
				/>
		</sequential>
	</macrodef>

	<target name="import-mediawiki-core-master">
		<import-project
			name="mediawiki/core"
			branch="master"
			dest="${sourcedir}"
			/>
	</target>

	<target name="import-wikidata">
		<import-project
			name="mediawiki/core"
			dest="${sourcedir}"
			/>
		<import-extension name="Wikibase" />
	</target>


	<!-- Nightly builds -->

	<!-- To test it:
		ant nightly-mediawiki-core -Dgit.shared.dir=/path/to/git/repos \
			-Dnightly.dir=/tmp/nightly
	-->
	<target name="nightly-mediawiki-core">
		<local name="projectname" />
		<property name="projectname" value="mediawiki/core" />
		<local name="remote.dir" />
		<property name="remote.dir" value="${git.shared.dir}/${projectname}" />

		<!-- Make sure our shared git repository has the latest values -->
		<git-remote-update dir="${remote.dir}" />

		<!-- Find sha1 for origin/master -->
		<local name="sha1" />
		<echo>Finding sha1 of origin/master in ${remote.dir}</echo>
		<exec executable="git" dir="${remote.dir}" failonerror="true"
			outputproperty="sha1" >
			<arg line="log --pretty=format:'%h' -n 1 origin/master" />
		</exec>

		<!-- git-archive does not create parent directories! -->
		<mkdir dir="${nightly.dir}/${projectname}" />
		<!-- prefix must have a trailing slash!! -->
		<git-archive
			output="${nightly.dir}/${projectname}/mediawiki-${sha1}.zip"
			remote="${remote.dir}"
			prefix="mediawiki-${sha1}/"
			treeish="origin/master"
			/>
		<symlink link="${nightly.dir}/${projectname}/mediawiki-latest.zip"
			resource="mediawiki-${sha1}.zip"
			overwrite="true" />
	</target>


	<!-- Check if a project was cloned by looking for .git dir
		Set property git.shared.exist.name/of/project

		Also look at <git-snapshot />
	 -->
	<macrodef name="git-cloned">
		<attribute name="name" />
		<sequential>
			<available
				file="${git.shared.dir}/@{name}/.git"
				type="dir"
				property="git.shared.exist.@{name}"
				/>
		</sequential>
	</macrodef>

	<!-- wrapper around git command
		http://tlrobinson.net/blog/2008/11/ant-tasks-for-git/
	-->
	<macrodef name="git">
		<attribute name="command" />
		<attribute name="dir" default="" />
		<attribute name="failonerror" default="true" />
		<element name="args" optional="true" />
		<sequential>
			<exec executable="git" dir="@{dir}" failonerror="@{failonerror}">
				<arg value="@{command}" />
				<args/>
			</exec>
		</sequential>
	</macrodef>

	<!-- archive a repository
		When giving a directory to prefix, make sure it ends with a trailing slash!
	-->
	<macrodef name="git-archive">
		<attribute name="output" />
		<attribute name="remote" />
		<attribute name="format"  default="zip" />
		<attribute name="prefix"  default="''" />
		<attribute name="treeish" default="HEAD" />
		<sequential>
			<git command="archive" failonerror="true">
				<args>
					<arg line="--format @{format}"  />
					<arg line="--output @{output}"  />
					<arg line="--prefix @{prefix}"  />
					<arg line="--remote=@{remote}" />
					<arg line="@{treeish}" />
				</args>
			</git>
		</sequential>
	</macrodef>

	<!-- clone a git repository
		 Fail if dest already exist! Use failonerror=false to ignore
	-->
	<macrodef name="git-clone">
		<attribute name="branch" default="master" />
		<attribute name="repository" />
		<attribute name="dest" />
		<attribute name="failonerror" default="true" />
		<attribute name="options" default="" />
		<sequential>
		<git command="clone" failonerror="@{failonerror}">
			<args>
				<arg line="@{options}" />
				<arg value="--" />
				<arg value="@{repository}" />
				<arg value="@{dest}" />
			</args>
		</git>
		</sequential>
	</macrodef>

	<!-- checkout a reference -->
	<macrodef name="git-checkout">
		<attribute name="commit" default="master" />
		<attribute name="dir" />
		<sequential>
			<git dir="@{dir}" command="checkout">
				<args><arg value="@{commit}" /></args>
			</git>
		</sequential>
	</macrodef>

	<macrodef name="git-clean-dfqx">
		<attribute name="dir" />
		<sequential>
			<git dir="@{dir}" command="clean">
				<args>
					<arg line="-d -f -q -x" />
				</args>
			</git>
		</sequential>
	</macrodef>

	<macrodef name="git-fetch">
		<attribute name="repository" />
		<attribute name="refspec" />
		<attribute name="dir" />
		<sequential>
			<git dir="@{dir}" command="fetch">
				<args>
					<arg value="@{repository}" />
					<arg value="@{refspec}" />
				</args>
			</git>
		</sequential>
	</macrodef>

	<macrodef name="git-merge">
		<attribute name="commit" />
		<attribute name="dir" />
		<sequential>
			<git dir="@{dir}" command="merge">
				<args><arg value="@{commit}" /></args>
			</git>
		</sequential>
	</macrodef>

	<macrodef name="git-merge-fetchhead">
		<attribute name="dir" />
		<sequential>
			<git dir="@{dir}" command="merge">
				<args><arg value="FETCH_HEAD" /></args>
			</git>
		</sequential>
	</macrodef>

	<macrodef name="git-remote-update">
		<attribute name="dir" />
		<sequential>
			<git dir="@{dir}" command="remote">
				<args><arg value="update"/></args>
			</git>
		</sequential>
	</macrodef>

	<macrodef name="git-reset">
		<attribute name="dir" />
		<attribute name="commit" />
		<attribute name="mode" />
		<sequential>
			<git dir="@{dir}" command="reset">
				<args>
					<arg value="@{mode}" />
					<arg value="@{commit}" />
				</args>
			</git>
		</sequential>
	</macrodef>

	<macrodef name="git-reset-hard">
		<attribute name="dir" />
		<attribute name="commit" />
		<sequential>
			<git-reset
				dir="@{dir}"
				commit="@{commit}"
				mode="--hard"
				/>
		</sequential>
	</macrodef>

	<!--
			Copy from @{remote} git repository rev @{treeish} to @{dest}
			This rely on 'git archive' and is way faster than doing a git clone.

			Usage Example:
			<git-snapshot
				remote="/var/lib/git/mediawiki/core"
				treeish="master"
				dest="/tmp/snapshot"
				/>
			-->
	<macrodef name="git-snapshot">
		<attribute name="remote"  />
		<attribute name="treeish" />
		<attribute name="dest"    />
		<sequential>
			<echo>Snapshoting @{remote} @{treeish} to @{dest}</echo>
			<!-- git-archive does not create parent directories! -->
			<mkdir dir="@{dest}" />
			<!-- Wrap execution in bash since we use a pipe -->
			<exec executable="bash">
				<arg value="-c" />
				<arg value="git archive --remote=@{remote} @{treeish} | (cd @{dest} &amp;&amp; tar xf - )" />
			</exec>
	</sequential>
	</macrodef>

</project>
